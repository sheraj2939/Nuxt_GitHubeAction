import { createError as createError$1 } from "/root/Nuxt_GitHubeAction/node_modules/h3/dist/index.mjs";
import { toRef } from "vue";
import { useNuxtApp } from "../nuxt.mjs";
import { useRouter } from "./router.mjs";
import { nuxtDefaultErrorValue } from "../../../../../_virtual/virtual_nuxt__root_Nuxt_GitHubeAction_.nuxt_nuxt.config.mjs";
const NUXT_ERROR_SIGNATURE = "__nuxt_error";
const useError = () => toRef(useNuxtApp().payload, "error");
const showError = (error) => {
  const nuxtError = createError(error);
  try {
    const nuxtApp = useNuxtApp();
    const error2 = useError();
    if (false) ;
    error2.value || (error2.value = nuxtError);
  } catch {
    throw nuxtError;
  }
  return nuxtError;
};
const clearError = async (options = {}) => {
  const nuxtApp = useNuxtApp();
  const error = useError();
  nuxtApp.callHook("app:error:cleared", options);
  if (options.redirect) {
    await useRouter().replace(options.redirect);
  }
  error.value = nuxtDefaultErrorValue;
};
const isNuxtError = (error) => !!error && typeof error === "object" && NUXT_ERROR_SIGNATURE in error;
const createError = (error) => {
  const nuxtError = createError$1(error);
  Object.defineProperty(nuxtError, NUXT_ERROR_SIGNATURE, {
    value: true,
    configurable: false,
    writable: false
  });
  return nuxtError;
};
export {
  NUXT_ERROR_SIGNATURE,
  clearError,
  createError,
  isNuxtError,
  showError,
  useError
};
//# sourceMappingURL=error.mjs.map
